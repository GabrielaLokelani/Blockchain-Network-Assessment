'use strict';;let BlockChain,Transaction,createDate,createWallet,openWallet,sockets,broadcast,responseLatestMsg,connectToPeers,nodeMap,getPeers,peerPool,MIEWCOIN_BLOCKCHAIN,faucetTransaction;_d2b‍.x([["http_port",()=>http_port],["initHttpServer",()=>initHttpServer]]);_d2b‍.w("./chain",[["default",["BlockChain"],function(v){BlockChain=v}]]);_d2b‍.w("./transaction",[["default",["Transaction"],function(v){Transaction=v}]]);_d2b‍.w("./block",[["createDate",["createDate"],function(v){createDate=v}]]);_d2b‍.w("./wallet",[["createWallet",["createWallet"],function(v){createWallet=v}],["openWallet",["openWallet"],function(v){openWallet=v}]]);_d2b‍.w("./node",[["sockets",["sockets"],function(v){sockets=v}],["broadcast",["broadcast"],function(v){broadcast=v}],["responseLatestMsg",["responseLatestMsg"],function(v){responseLatestMsg=v}],["connectToPeers",["connectToPeers"],function(v){connectToPeers=v}],["nodeMap",["nodeMap"],function(v){nodeMap=v}],["getPeers",["getPeers"],function(v){getPeers=v}],["peerPool",["peerPool"],function(v){peerPool=v}]]);_d2b‍.w("../index",[["MIEWCOIN_BLOCKCHAIN",["MIEWCOIN_BLOCKCHAIN"],function(v){MIEWCOIN_BLOCKCHAIN=v}]]);_d2b‍.w("./faucet",[["faucetTransaction",["faucetTransaction"],function(v){faucetTransaction=v}]]);

// IMPORT RELEVANT LIBRARIES
const express = require('express');
const WebSocket = require('ws');
const path = require('path');










       const http_port = process.env.HTTP_PORT || 5555;;_d2b‍.j(["http_port"]);

// rest api logic for blocks, createWallet, pendingTransactions, minePendingTransactions, peers, sendTransactions, ect...
       function initHttpServer() {
    let app = express();
    app.use(express.urlencoded({ extended: false }));
    app.use(express.json());
    app.set('view engine', 'ejs');
    app.engine('html', require('ejs').renderFile);
    app.use(express.static('public'));

    //  Homepage
    app.get('/home', (req, res) => {
        res.render('../views/home.html');
    });

    app.get('/info', (req, res) => {
        res.send();
    })

    // get block explorer page
    app.get('/blockExplorer', (req, res) => {
        res.render('../views/blockExplorer.html');
    });

    // get wallet explorer page
    app.get('/wallet', (req, res) => {
        res.render('../views/wallet.html');
    });

    // gets the open existing wallet html page
    app.get('/openWallet', (req, res) => {
        res.render('../views/openWallet.html');
    });

    // enter a privatekey to open an exisitng wallet, if privkey is wrong an error will throw
    app.post('/openWallet', (req, res) => {
        if (req.body.privKey) {
            let openedWallet = _d2b‍.a("openWallet",openWallet)(req.body.privKey);
            res.send({ 'address:': openedWallet.address, "publicKey": openedWallet.pubKey, "publicKeyCompressed": openedWallet.publicKeyCompressed, "privKey": openedWallet.privateKey});
        } else {
            throw new Error("Sorry we could not find a wallet for that private key, check to make sure it is entered correctly.")
        }
    });

    // get all blocks in the blockchain
    app.get('/blocks', (req, res) => res.send(JSON.stringify(_d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN))));

    // get a specific block by its index 
    app.get('/blockIndex/:index', (req, res) => {
        res.send(JSON.stringify(_d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getBlock(req.params.index)));
    });

    // create a new wallet and return the address, private and public keys
    app.get('/createWallet', (req, res) => {
        let newWallet = _d2b‍.a("createWallet",createWallet)();
        res.send({ 'address:': newWallet.address, "publicKey": newWallet.pubKey, "publicKeyCompressed": newWallet.publicKeyCompressed, "privKey": newWallet.privateKey});
    });

    // get all pending transactions
    app.get('/transactions/pending', (req, res) => {
        res.send(JSON.stringify(_d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).pendingTransactions));
    });

    // get all confirmed transactions 
    app.get('/transactions/confirmed', (req, res) => {
        const confirmedTXNs = _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getConfirmedTransactions();
        res.send(confirmedTXNs);
    });

    // get specific transaction by its hash 
    app.get('/transactionHash/:txnHash', (req, res) => {
        const transaction = _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getTransactionByHash(req.params.txnHash);
        res.send(transaction);
    });

    // get the send transaction page
    app.get('/transaction/send', (req, res) => {
        res.render('../views/sendTransaction.html');
    });

    // send a new transaction
    app.post('/transaction/send', (req, res) => {
        // create a new transaction
        if (req.body.fee >= 10 && req.body.from != null && req.body.to != null) {
            const newTXN = new (_d2b‍.a("Transaction",Transaction))(req.body.from, req.body.to, req.body.value, req.body.fee, _d2b‍.a("createDate",createDate)(), req.body.data, req.body.senderPubKey);
            // sign 
            newTXN.signTransaction(req.body.senderPrivKey, req.body.scrtMsg);

            // submit txn
            _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).addTransaction(newTXN);
            _d2b‍.g.console.log("Here is your new Transaction Hash: " + newTXN.transactionHash);
            res.redirect('/home');
        } else {
            res.send("Sorry, your transaction is missing either a to or from address or the fee is less than 10 micro coins");
        }
        res.send();
    });

    // get all??? balances ** need to do **
    app.get('/balances', (req, res) => {
        let balances = _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).allBalances()
        res.send(balances);
    });

    // get all transactions for a specific address 
    app.get('/address/:address/transactions', (req, res) => {
        const transactions = _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getTransactionsForAddress(req.params.address);
        res.send(transactions);
    });

    // get the balance for a specific address 
    app.get('/address/:address/balance', (req, res) => {
        let confirmedBalance = _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getConfirmedBalanceOfAddress(req.params.address);
        let safeBalance = _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getSafeBalanceOfAddress(req.params.address);
        let pendingBalance = _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getPendingBalanceOfAddress(req.params.address);
        res.send({
            "confirmedBalance": confirmedBalance.toString(),
            "safeBalance": safeBalance.toString(),
            "pendingBalance": pendingBalance.toString()
        });
    });    

    // get miner main page
    app.get('/miner', (req, res) => {
        res.render('../views/miner.html');
    });

    // get minePendingTransactions / mineNextBlock html page and form to be able to mine the next block
    app.get('/minePendingTransactions', (req, res) => {
        res.render('../views/mineNextBlock.html');
    });

    // mine pending txns to mine the next block (all in one solution, no mining job and block candidate loading, use for testing purposes)
    app.post('/minePendingTransactions', (req, res) => {
        // submit miners address and init the miner
        _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).minePendingTransactions(req.body.miningRewardAddress);
        _d2b‍.a("broadcast",broadcast)(_d2b‍.a("responseLatestMsg",responseLatestMsg)());
        res.redirect('/home');
    });

    // get mining job page (just pulls up mineNextBlock html)
    app.get('/getMiningJob/:minerAddress', (req, res) => {
        let blockCandidate = _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getMiningJob(req.params.minerAddress);
        let transactions = blockCandidate.transactions;
        let transactionsLength = transactions.length;
        res.render('../views/mineNextBlock.html', { blockCandidateInfo: `{
            index: ${blockCandidate.index},
            transactionsIncluded: ${transactionsLength},
            difficulty: ${blockCandidate.difficulty},
            expectedReward: ${transactions[0].value},
            rewardAddress: ${blockCandidate.minedBy},
            blockDataHash: ${blockCandidate.blockDataHash}
        }`, blockCandidate: `${JSON.stringify(blockCandidate)}` });
    });

    // get mining job, prepare the next block candidate for the miner
    app.post('/getMiningJob/:minerAddress', (req, res) => {
        let newBlock = _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).mineBlockCandidate(req.body.blockDataHash);
        res.render('../views/minedBlock.html', { minedBlockInfo: `{
            blockHash: ${newBlock.blockHash},
            nonce: ${newBlock.nonce},
            dateCreated: ${newBlock.dateCreated},
            blockDataHash: ${newBlock.blockDataHash}
        }` });
    });

    // get submit mined block candidate page
    app.get('/submitMinedBlock', (req, res) => {
        res.render('../views/submitMinedBlock.html');
    });

    // post the new mined block for submission and approval to be added to the chain
    app.post('/submitMinedBlock', (req, res) => {
        _d2b‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).submitMinedBlock(req.body.blockHash, req.body.dateCreated, req.body.nonce, req.body.blockDataHash);
        _d2b‍.a("broadcast",broadcast)(_d2b‍.a("responseLatestMsg",responseLatestMsg)());
        res.send("Congratulations, You have successfully mined the next block in the chain!")
    });

    // reset the chain for debugging purposes
    app.post('/resetChain', (req, res) => {
        let MIEWCOIN_BLOCKCHAIN = new (_d2b‍.a("BlockChain",BlockChain))();
        res.send(JSON.stringify(MIEWCOIN_BLOCKCHAIN));
    })

    // get array of connected peers
    app.get('/peers', (req, res) => {
        let socketMap = _d2b‍.a("sockets",sockets).map(s => s._socket.remoteAddress + ':' + s._socket.remotePort);
        let peer = _d2b‍.a("getPeers",getPeers)();
        res.status(200).send(_d2b‍.a("peerPool",peerPool))
        // res.send(`${peer}`, socketMap);
    });

    app.get('/peers/connect', (req, res) => {
        res.render('../views/peersConnect.html');
    })

    // add a peer to the network
    app.post('/peers/connect', (req, res) => {
        let peer = _d2b‍.a("connectToPeers",connectToPeers)([req.body.p2pPeerPort]);
        res.redirect("/peers");
    });

    // notify peers of new block ** need to do **
    app.get('/peers/notify-new-block', (req, res) => {
        let msg = _d2b‍.a("broadcast",broadcast)(_d2b‍.a("responseLatestMsg",responseLatestMsg)());
        res.send(msg);
    });

    app.listen(http_port, () => _d2b‍.g.console.log('Listening http on port: ' + http_port));
}