
'use strict';;let MIEWCOIN_BLOCKCHAIN,createDate,http_port;_7c1‍.x([["initialPeers",()=>initialPeers],["nodeMap",()=>nodeMap],["peerMap",()=>peerMap],["peerPool",()=>peerPool],["sockets",()=>sockets],["MessageType",()=>MessageType],["default",()=>Node],["initP2PServer",()=>initP2PServer],["createNode",()=>createNode],["node",()=>node],["connectToPeers",()=>connectToPeers],["queryChainLengthMsg",()=>queryChainLengthMsg],["queryAllMsg",()=>queryAllMsg],["responseChainMsg",()=>responseChainMsg],["responseLatestMsg",()=>responseLatestMsg],["broadcast",()=>broadcast]]);_7c1‍.w("../index",[["MIEWCOIN_BLOCKCHAIN",["MIEWCOIN_BLOCKCHAIN"],function(v){MIEWCOIN_BLOCKCHAIN=v}]]);_7c1‍.w("./block",[["createDate",["createDate"],function(v){createDate=v}]]);_7c1‍.w("./server",[["http_port",["http_port"],function(v){http_port=v}]]);

// IMPORT RELEVANT LIBRARIES
const CryptoJS = require('crypto-js');
const express = require('express');
const WebSocket = require('ws');
const path = require('path')
const bodyParser = require('body-parser');




const p2p_port = process.env.P2P_PORT || 3333;
       const initialPeers = process.env.PEERS ? process.env.PEERS.split(',') : [];;_7c1‍.j(["initialPeers"]);

       let nodeMap = new Map();;_7c1‍.j(["nodeMap"]);
       let peerMap = new Map();;_7c1‍.j(["peerMap"]);
       var peerPool = [];;_7c1‍.j(["peerPool"]);
       var sockets = [];;_7c1‍.j(["sockets"]);
let genesisHash = '';
       let MessageType = {
    QUERY_LATEST: 0,
    QUERY_ALL: 1,
    RESPONSE_BLOCKCHAIN: 2
};;_7c1‍.j(["MessageType"]);

               class Node {
    constructor(selfURL, p2p, peers, chain) {
        this.nodeID = this.calculateNodeID(),
        this.selfURL = selfURL,
        this.p2p = p2p,
        this.peers = peers,
        this.chain = chain
    }

    calculateNodeID() {
        let date = _7c1‍.a("createDate",createDate)();
        let random = Math.floor(Math.random() * 1000);
        return CryptoJS.SHA256(date.toString() + random.toString()).toString();
    }
}_7c1‍.j(["default"]);

// create the P2P server to let nodes interact
       let initP2PServer = () => {
    let server = new WebSocket.Server({port: p2p_port});
    server.on('connection', ws => initConnection(ws));
    _7c1‍.g.console.log('Listening websocket p2p on port: ' + p2p_port);
    genesisHash = _7c1‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).chain[0].blockHash;
    _7c1‍.g.console.log("here is the genesis hash: ", genesisHash);
};;_7c1‍.j(["initP2PServer"]);

       function createNode() {
    let node = new Node(`http://localhost:${_7c1‍.a("http_port",http_port)}`, `http://localhost:${p2p_port}`, peerPool, chain);
    _7c1‍.g.console.log("Here is the node after creation: ", node);
    let nodeString = JSON.stringify(node);
    nodeMap.set(`${node.nodeID}`, `${nodeString}`);
    return node
}

       let node = createNode();_7c1‍.j(["node"]);

// handle the blockchain and responses for the nodes when a new event occurs
let handleBlockchainResponse = (message) => {
    let receivedBlocks = JSON.parse(message.data);
    if (!receivedBlocks.chain) {
        receivedBlocks.sort(function(a, b) { 
            return a.index - b.index;
        });
    } else {
        receivedBlocks = receivedBlocks.chain;
        receivedBlocks.sort(function(a, b) { 
            return a.index - b.index;
        });
    }
    let latestBlockReceived = receivedBlocks[receivedBlocks.length - 1];
    let latestBlockHeld = _7c1‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getBlock(_7c1‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getHeight());
    if (latestBlockReceived.index > latestBlockHeld.index) {
        _7c1‍.g.console.log('blockchain possibly behind. We got: ' + latestBlockHeld.index + ' Peer got: ' + latestBlockReceived.index);
        if (latestBlockHeld.blockHash === latestBlockReceived.previousBlockHash) {
            console.log("We can append the received block to our chain");
            _7c1‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).addBlock(latestBlockReceived);
            broadcast(responseLatestMsg());
        } else if (receivedBlocks.length === 1) {
            console.log("We have to query the chain from our peer");
            broadcast(queryAllMsg());
        } else {
            console.log("Received blockchain is longer than current blockchain");
            _7c1‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).replaceChain(receivedBlocks);
        }
    } else {
        console.log('received blockchain is not longer than current blockchain. Do nothing');
    }
};

var initMessageHandler = (ws) => {
    ws.on('message', (data) => {
        var message = JSON.parse(data);
        _7c1‍.g.console.log('Recieved message: ' + JSON.stringify(message));
        switch (message.type) {
            case MessageType.QUERY_LATEST:
                write(ws, responseLatestMsg());
                break;
            case MessageType.QUERY_ALL:
                write(ws, responseChainMsg());
                break;
            case MessageType.RESPONSE_BLOCKCHAIN:
                handleBlockchainResponse(message);
                break;
        }
    });
};

var initErrorHandler = (ws) => {
    var closeConnection = (ws) => {
        _7c1‍.g.console.log('connection failed to peer: ' + ws.url);
        sockets.splice(sockets.indexOf(ws), 1);
        peerPool.splice(peerPool.indexOf(ws), 1);
    };
    ws.on('close', () => closeConnection(ws));
    ws.on('error', () => closeConnection(ws));
};

let initConnection = (ws, nodeID) => {
    sockets.push(ws);
    if (ws.url){
        addToPeerPool(ws.url, nodeID);
    }
    initMessageHandler(ws);
    initErrorHandler(ws);
    write(ws, queryChainLengthMsg());
};

function addToPeerPool(wsURL, nodeID) {
    wsURL = wsURL.substring(2);
    let str = "https"
    let p2p = str.concat(wsURL);
    peerMap.set(`${nodeID}`, `${p2p}`);
    let connection = {
        NodeId: nodeID,
        P2P_Port: p2p
    }
    peerPool.push(connection);
}

       let connectToPeers = (newPeers, nodeID) => {
    newPeers.forEach((peer) => {
        let ws = new WebSocket(peer);
        _7c1‍.g.console.log("Peer is being connected: ", peer);
        ws.on('open', () => initConnection(ws, nodeID));
        ws.on('error', () => {
            console.log('connection failed')
        });
        return peer
    });
};;_7c1‍.j(["connectToPeers"]);

       let queryChainLengthMsg = () => ({'type': MessageType.QUERY_LATEST});;_7c1‍.j(["queryChainLengthMsg"]);
       let queryAllMsg = () => ({'type': MessageType.QUERY_ALL});;_7c1‍.j(["queryAllMsg"]);
       let responseChainMsg = () =>({
    'type': MessageType.RESPONSE_BLOCKCHAIN, 'data': JSON.stringify(_7c1‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN))
});;_7c1‍.j(["responseChainMsg"]);
       let responseLatestMsg = () => ({
    'type': MessageType.RESPONSE_BLOCKCHAIN,
    'data': JSON.stringify([_7c1‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getBlock(_7c1‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).getHeight())])
});;_7c1‍.j(["responseLatestMsg"]);

let write = (ws, message) => ws.send(JSON.stringify(message));
       var broadcast = (message) => sockets.forEach(socket => write(socket, message));;_7c1‍.j(["broadcast"]);

function getChain() {
    let genesisHash = _7c1‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).chain[0].blockHash;
    _7c1‍.g.console.log("here is the genesis hash: ", genesisHash);
    return genesisHash
}