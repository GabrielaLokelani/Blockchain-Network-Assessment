_bfc‍.x([["default",()=>Block],["calculateBlockHash",()=>calculateBlockHash],["createDate",()=>createDate]]);
// IMPORT RELEVANT LIBRARIES
const CryptoJS = require('crypto-js');
const jsdom = require("jsdom");
const { JSDOM } = jsdom;

// create the block class which each new block will follow
               class Block {
    constructor(index, transactions, difficulty, minedBy, previousBlockHash, dateCreated) {
        this.index = index;
        this.transactions = transactions;
        this.difficulty = difficulty;
        this.previousBlockHash = previousBlockHash.toString();
        this.minedBy = minedBy.toString();
        this.blockDataHash = this.calculateBlockDataHash();
        // this.nonce = 0;
        // this.dateCreated = dateCreated;
        // this.blockHash = this.calculateBlockHash();
    }

    // calculate the block DATA hash using SHA256
    calculateBlockDataHash() {
        return CryptoJS.SHA256(this.index + JSON.stringify(this.transactions) + this.difficulty + this.previousBlockHash + this.minedBy).toString();
    }

    // calculate the block hash using SHA256 which takes the blockDataHash and nonce
    calculateBlockHash() {
        return CryptoJS.SHA256(this.blockDataHash + this.dateCreated + this.nonce).toString();
    }

    // check the validity of each transaction in the block and make sure there are no missing values
    checkTransactionsValidity() {
        for (const txn of this.transactions) {
        if (!txn.from || !txn.to || !txn.value || !txn.fee || !txn.data || !txn.senderPubkey) {
            throw new Error('Sorry! Transaction is missing a value.');
        } else {
            return true;
        }
        }
    }

    // mine the block POW taking in difficulty and newblock data
    mineBlock(difficulty) {
        while (this.blockHash.substring(0, difficulty) !== Array(difficulty + 1).join("0")) {
            this.nonce++;
            this.blockHash = this.calculateBlockHash();
        }
        this.dateCreated = createDate();
        const newBlockHash = this.calculateBlockHash();

        console.log("Block mined, nonce: " + this.nonce + ", hash: " + newBlockHash);
    }
}

// calculate the blockhash (block data hash + dateCreated + nonce) for outside the block class 
       function calculateBlockHash(newBlock) {
    return CryptoJS.SHA256(newBlock.blockDataHash + newBlock.dateCreated + newBlock.nonce).toString();
}

// create an accurate date in ISO format
       function createDate() {
    let date1 = new Date();
    let date = date1.toISOString();
    return date
}


