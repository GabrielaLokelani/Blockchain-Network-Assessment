let Block,calculateBlockHash,createDate,MIEWCOIN_BLOCKCHAIN,Transaction,broadcast,responseLatestMsg;_588‍.x([["default",()=>BlockChain]]);_588‍.w("./block",[["default",["Block"],function(v){Block=v}],["calculateBlockHash",["calculateBlockHash"],function(v){calculateBlockHash=v}],["createDate",["createDate"],function(v){createDate=v}]]);_588‍.w("../index",[["MIEWCOIN_BLOCKCHAIN",["MIEWCOIN_BLOCKCHAIN"],function(v){MIEWCOIN_BLOCKCHAIN=v}]]);_588‍.w("./transaction",[["default",["Transaction"],function(v){Transaction=v}]]);_588‍.w("./node",[["broadcast",["broadcast"],function(v){broadcast=v}],["responseLatestMsg",["responseLatestMsg"],function(v){responseLatestMsg=v}]]);




// IMPORT RELEVANT LIBRARIES
const CryptoJS = require('crypto-js');

               class BlockChain {
    constructor() {
        this.chain = [this.creationOfGenesisBlock()];
        // this.difficulty = 2;
        this.pendingTransactions = [];
        this.miningReward = 5000000;
    }

    creationOfGenesisBlock() {
        return new (_588‍.a("Block",Block))(0, [], "0000000000000000000000000000000000000000", _588‍.a("createDate",createDate)(), '')
    }

    // The method to get the current height of the chain (the latest added block in the chain length).
    getHeight() {
      return this.chain.length - 1;
    }

    //  Method to get a specific block of the chain, set by height (the specific index in the chain).
    getBlock(height) {
        return this.chain[height];
    }

    fetchLatestBlock() {
        return this.chain[this.chain - 1];
    }

    returnChain() {
        return this.chain;
    }

    minePendingTransactions(miningRewardAddress) {
        const latestBlock = this.getBlock(this.getHeight());
        let newIndex = latestBlock.index + 1;

        let block = new (_588‍.a("Block",Block))(newIndex, this.pendingTransactions, miningRewardAddress, _588‍.a("createDate",createDate)(), latestBlock.blockHash);

        block.mineBlock(2, block);
        console.log('Block was successfully mined!');

        _588‍.a("MIEWCOIN_BLOCKCHAIN",MIEWCOIN_BLOCKCHAIN).addBlock(block);

        // Put the miner fee transaction into pendingTransactions for the next processing operation??? The miner fee transaction is characterized by the source account being empty.
        this.pendingTransactions = [];

        // ?? should the minertxn be the fee from the txns being mined AND the reward and *** main issue rn is how to do all those txns and signing with privkeys
        // for (const txn of block.transactions) {
        //     // issue with getting paid with the mining fee and mining reward bc it takes extra coins from sender who should only pay fee, "00000..." should pay that reward with coinbase txn
        //     const minerTXN = new Transaction(txn.from, miningRewardAddress, txn.fee, 0, Date.now(), "mining reward!", txn.senderPubKey);
        //     console.log("here is the new supposed txn for the miners reward:    " + JSON.stringify(minerTXN));
        //     minerTXN.signTransaction(txn.senderPrivKey);
        //     console.log("here is the minerTXN senders privkey:   " + txn.senderPrivKey);
        //     MIEWCOIN_BLOCKCHAIN.addTransaction(minerTXN);
        // }

        let totalFees = 0;
        for (const txn of block.transactions) {
            totalFees += txn.fee;
        }
        _588‍.g.console.log("total fees in this block:   " + totalFees);
        let totalReward = totalFees + this.miningReward;
        const minerTXN = new (_588‍.a("Transaction",Transaction))("0000000000000000000000000000000000000000", miningRewardAddress, totalReward, 0, _588‍.a("createDate",createDate)(), "mining reward!", "00000000000000000000000000000000000000000000000000");
        minerTXN.signRewardTransaction("00000000000000000000000000000000000000000000000000");
        this.pendingTransactions.push(minerTXN);


        return block;
    }

    addTransaction(transaction) {
        if (!transaction.from || !transaction.to) {
            throw new Error('Sorry! Transaction must include a from and to address');
        }

        if (!transaction.isValid()) {
            throw new Error('Cannot add invalid transaction to the chain');
        }

        // push to mempool
        this.pendingTransactions.push(transaction)
    }

    // get balance of an address
    getBalanceOfAddress(address) {
        let balance = 0;
        for (const block of this.chain) {
            for (const transaction of block.transactions) {
                if (transaction.from === address) {
                    balance -= transaction.value;
                    balance -= transaction.fee;
                }

                if (transaction.to === address) {
                    balance += transaction.value;
                }

                if (transaction.from === "0000000000000000000000000000000000000000") {
                    balance += transaction.fee;
                }
            }
        }
        return balance;
    }

    // get all confirmed transactions
    getConfirmedTransactions() {
        let listOfTXN = "";
        for (const block of this.chain) {
            if (block.transactions != null) {
                listOfTXN = JSON.stringify(block.transactions);
                // return block.transactions;
            }
        }
        return listOfTXN;
    }

    // get all transactions for a specific address 
    getTransactionsForAddress(address) {
        let listOfTXN = "";
        for (const block of this.chain) {
            for (const transaction of block.transactions) {
                if (transaction.from === address) {
                    listOfTXN = JSON.stringify(transaction);
                }
            }
        }
        return listOfTXN;
    }

    // get specific transaction by its hash
    getTransactionByHash(txnHash) {
        let txn = "";
        for (const block of this.chain) {
            for (const transaction of block.transactions) {
                if (transaction.transactionHash === txnHash) {
                    txn = JSON.stringify(transaction);
                }
            }
        }
        return txn;
    }

    isChainValid() {
        for (let i = 1; i < this.chain.length; i++) {
            const currentBlock = this.chain[i];
            const previousBlock = this.chain[i - 1];
            // testing purposes 
            _588‍.g.console.log('current blockhash' + currentBlock.blockHash);
            _588‍.g.console.log('calculated blockhash' + currentBlock.calculateBlockHash());
            // Check if all transactions in the block are valid.
            if (!currentBlock.checkTransactionsValidity()) {
                return false;
            }
            if (currentBlock.blockHash !== currentBlock.calculateBlockHash()) {
                _588‍.g.console.error("hash not equal: " + JSON.stringify(currentBlock));
                return false;
            }
            if (currentBlock.previousBlockHash !== previousBlock.calculateBlockHash()) {
                _588‍.g.console.error("previous hash is not right: " + JSON.stringify(currentBlock));
                return false;
            }
        }
        return true;
    }

    isValidNewBlock(newBlock, previousBlock) {
        if (previousBlock.index + 1 !== newBlock.index) {
            console.log('invalid index');
            return false;
        } else if (previousBlock.blockHash !== newBlock.previousBlockHash) {
            console.log('invalid previous Hash');
            return false;
        } else if (_588‍.a("calculateBlockHash",calculateBlockHash)(newBlock) !== newBlock.blockHash) {
            return false;
        }
        return true;
    }

    addBlock(newBlock) {
        const latestBlock = this.getBlock(this.getHeight());
        _588‍.g.console.log('is new block valid? ' + this.isValidNewBlock(newBlock, latestBlock))
        if (this.isValidNewBlock(newBlock, latestBlock)) {
            this.chain.push(newBlock);
        }
    }

    isValidChain(blockchainToValidate) {
        if (JSON.stringify(blockchainToValidate[0]) !== JSON.stringify(this.creationOfGenesisBlock())) {
            return false;
        }
        var tempBlocks = [blockchainToValidate[0]];
        for (let i = 1; i < blockchainToValidate.length; i++) {
            if (this.isValidNewBlock(blockchainToValidate[i], tempBlocks[i - 1])) {
                tempBlocks.push(blockchainToValidate[i]);
            } else {
                return false;
            }
        }
        return true;
    }

    replaceChain(newBlocks) {
        if (this.isValidChain(newBlocks) && newBlocks.length > this.chain.length) {
            console.log('recieved blockchain is valid. Replacing current blockchain with recieved blockchain');
            this.chain = newBlocks;
            _588‍.a("broadcast",broadcast)(_588‍.a("responseLatestMsg",responseLatestMsg)());
        } else {
            console.log('recieved blockchain is invalid');
        }            
    }

}_588‍.j(["default"]);
