"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createQuantileSeqTransform = void 0;
var _factory = require("../../utils/factory.js");
var _quantileSeq = require("../../function/statistics/quantileSeq.js");
var _lastDimToZeroBase = require("./utils/lastDimToZeroBase.js");
var name = 'quantileSeq';
var dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare', 'isInteger'];

/**
 * Attach a transform function to math.quantileSeq
 * Adds a property transform containing the transform function.
 *
 * This transform changed the `dim` parameter of function std
 * from one-based to zero based
 */
var createQuantileSeqTransform = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {
  var typed = _ref.typed,
    add = _ref.add,
    multiply = _ref.multiply,
    partitionSelect = _ref.partitionSelect,
    compare = _ref.compare,
    isInteger = _ref.isInteger;
  var quantileSeq = (0, _quantileSeq.createQuantileSeq)({
    typed: typed,
    add: add,
    multiply: multiply,
    partitionSelect: partitionSelect,
    compare: compare,
    isInteger: isInteger
  });
  return typed('quantileSeq', {
    'Array|Matrix, number|BigNumber|Array, number': function ArrayMatrixNumberBigNumberArrayNumber(arr, prob, dim) {
      return quantileSeq(arr, prob, dimToZeroBase(dim));
    },
    'Array|Matrix, number|BigNumber|Array, boolean, number': function ArrayMatrixNumberBigNumberArrayBooleanNumber(arr, prob, sorted, dim) {
      return quantileSeq(arr, prob, sorted, dimToZeroBase(dim));
    }
  });
  function dimToZeroBase(dim) {
    // TODO: find a better way, maybe lastDimToZeroBase could apply to more cases.
    return (0, _lastDimToZeroBase.lastDimToZeroBase)([[], dim])[1];
  }
}, {
  isTransformFunction: true
});
exports.createQuantileSeqTransform = createQuantileSeqTransform;